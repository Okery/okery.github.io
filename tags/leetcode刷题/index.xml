<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode刷题 on LiuHe&#39;s blog</title>
    <link>https://okery.github.io/tags/leetcode%E5%88%B7%E9%A2%98/</link>
    <description>Recent content in leetcode刷题 on LiuHe&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Oct 2019 14:43:58 +0800</lastBuildDate>
    
	<atom:link href="https://okery.github.io/tags/leetcode%E5%88%B7%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>leetcode刷题-11-盛最多水的容器</title>
      <link>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 22 Oct 2019 14:43:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>问题描述 给定 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 n 的值至少为 2。
示例 输入: [1,8,6,2,5,4,8,3,7] 输出: 49  实现 #### 1 暴力破解
暴力破解，时间复杂度$$O(n^{2})$$,超出官方指定时间限制，自己跑了一下大约是两秒半
def max_area(height_list): height_num = len(height_list) max_area = 0 for i in range(height_num): current_val = height_list[i] for j in range(i+1, height_num): if current_val &amp;lt;= height_list[j]: area = current_val * (j-i) else: area = height_list[j] * (j-i) if max_area &amp;lt; area: max_area = area return max_area`  2 双指针法 头尾指针 头尾指针，双向移动，每次移动较小值，时间复杂度$$O(n)$$</description>
    </item>
    
    <item>
      <title>leetcode刷题-16-最接近的三数之和</title>
      <link>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 22 Oct 2019 14:43:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>问题描述 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例 给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
实现 双指针两侧扩展 双指针从目标值开始，同时向两侧扩展，取最先遇到的三个数相加
def three_sum_clostest(nums, target): &amp;quot;&amp;quot;&amp;quot; 给定一个包括n个整数的数组nums和一个目标值target。 找出nums中的三个整数,使得它们的和与target最接近。返回这三个数的和。 假定每组输入只存在唯一答案。 &amp;quot;&amp;quot;&amp;quot; result_sum = 0 pre_distance = {} if target&amp;lt;0: max_width = len(nums) - target else: max_width = len(nums) + target current_nums_num = 0 break_flag = False for x in nums: # print(x) current_dis = (target - x) if current_dis &amp;lt; 0: current_dis = - current_dis if pre_distance.</description>
    </item>
    
    <item>
      <title>leetcode刷题-26-删除有序数组重复项</title>
      <link>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Tue, 22 Oct 2019 14:43:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>问题描述 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成
示例 给定数组 nums = [1,1,2],
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
你不需要考虑数组中超出新长度后面的元素。
实现 双指针移动 设置主指针move_pointer和检查指针check_pointer,check_pointer永远在move_pointer后一位，若两个位置元素相等，则删掉数组move_pointer指向元素，数组长度减一，指针不动，继续判断，若两个位置元素不相等，则两指针同时往后移动一位，直至check_pointer移动到数组最后一位为止
def remove_duplicates(nums): &amp;quot;&amp;quot;&amp;quot; 不能使用额外数组 双指针移动 &amp;quot;&amp;quot;&amp;quot; reslut_len = len(nums) move_pointer = 0 check_pointer = 1 while (check_pointer != reslut_len and reslut_len != 0): if(nums[check_pointer] == nums[move_pointer]): del(nums[check_pointer]) reslut_len -= 1 else: move_pointer += 1 check_pointer += 1 return reslut_len nums = [1, 1, 2] result = remove_duplicates(nums) print(result)  总结 需要注意边界条件，输入数组可能为空值，在循环遍历时要注意数组为空的情况和索引的设置</description>
    </item>
    
    <item>
      <title>leetcode刷题-27-移除元素</title>
      <link>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 22 Oct 2019 14:43:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>问题描述 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例 给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
实现 单指针移动，当前值不等于目标值，指针向后移动一位，当前值等于目标值，指针不动，删掉当前元素，数组长度减一
def remove_element(nums, val): nums_len = len(nums) index = 0 while(index != nums_len): if(nums[index] == val): del(nums[index]) nums_len -= 1 else: index += 1 return nums_len nums = [3, 2, 2, 3] val = 3 result = remove_element(nums, val) print(result)  总结 使用while循环往往比for循环要好一些，边界值判断、索引值设定更加简单</description>
    </item>
    
    <item>
      <title>leetcode刷题-1-两数相加</title>
      <link>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-1-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sun, 20 Oct 2019 14:43:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/leetcode%E5%88%B7%E9%A2%98-1-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>立个flag，研二去北京实习，别让女朋友等那么久了
问题描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例 给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]
实现 1 暴力破解 首先想到的是暴力破解，也能跟后面其他方法对比一下复杂度
def two_sum_vio(nums, target): num_len = len(nums) results = [] for i in range(0, num_len): flage = False remainder = target - nums[i] for j in range(0, num_len): if(nums[j] == remainder and j != i): results.</description>
    </item>
    
  </channel>
</rss>