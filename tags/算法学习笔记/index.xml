<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法学习笔记 on LiuHe&#39;s blog</title>
    <link>https://okery.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 算法学习笔记 on LiuHe&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Sep 2019 14:23:58 +0800</lastBuildDate>
    
	<atom:link href="https://okery.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>杨辉三角</title>
      <link>https://okery.github.io/post/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</link>
      <pubDate>Sat, 21 Sep 2019 14:23:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</guid>
      <description>杨辉三角
python实现输出指定行数的杨辉三角 # -*- coding: utf-8 -*- # @Date : 2019-09-20 14:22:58 # @Author : LiuHe (liuh131@163.com) # @Link : https://okery.github.io/ # @Version : $Id$ # @Name : 生成指定行数的杨辉三角 # 生成杨辉三角 def triangle(row): # 使用二维数组存储内容 trianles = [] for j in range(row): triangle_inner = [] for i in range(j): if i == 0 or i == (j - 1): triangle_inner.append(1) else: tmp = trianles[j - 1][i - 1] + trianles[j - 1][i] triangle_inner.</description>
    </item>
    
    <item>
      <title>算法学习笔记-筛选质数算法</title>
      <link>https://okery.github.io/post/%E7%AD%9B%E9%80%89%E8%B4%A8%E6%95%B0%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 18 Sep 2019 20:23:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/%E7%AD%9B%E9%80%89%E8%B4%A8%E6%95%B0%E7%AE%97%E6%B3%95/</guid>
      <description>筛选算法——筛选指定范围内的质数
案例 指定范围为：1-20
数组为：
​ 1 2 3 4 5
​ 6 7 8 9 10
​ 11 12 13 14 15
​ 16 17 18 19 20
​ 21 22 23 24 25
1.去掉2的倍数
2.去掉3的倍数
3.去掉4的倍数
4.去掉5的倍数
去掉方法为：
​ j = i * i
​ j = j + i
​ i二次幂肯定为i的倍数，所以不为质数，去掉
​ 从i * i 处开始，以i为步长往后对应的数肯定为i的倍数，所以不为质数，去掉
​ 本案例范围为1-25，所以最高去掉5的倍数即可
算法实现 # 筛选算法 # 筛选给定范围内的质数 # 给定范围，将数据存放进数组，将非质数所在位置设为0，返回数组 def find_prime_number(a): numbers = [] # 初始化数组，将数据填充进数组 for i in range(1, a+1): numbers.</description>
    </item>
    
    <item>
      <title>算法学习笔记-欧几里得算法实现</title>
      <link>https://okery.github.io/post/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 18 Sep 2019 14:43:58 +0800</pubDate>
      
      <guid>https://okery.github.io/post/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</guid>
      <description> 欧几里得算法 欧几里得算法用来计算两个整数的最大公约数
公式 ​ gcd(a, b) = gcd(b, a mod b)
原理 ​ 两个整数的最大公约数等于其中较小的那个数和两数相除的最大公约数
实现 ​ 递归实现
def gcd_recursion(a, b): if b == 0: return a return gcd_re(b, a % b) print(gcd_re(6, 4))  ​ 非递归实现
def gcd_no_recursion(a, b): while b != 0: tmp = a % b a = b b = tmp return a  </description>
    </item>
    
  </channel>
</rss>